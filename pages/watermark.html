<div class="contents_block">
    <h1>透かし加工ツール</h1>
</div>

<div class="contents_block">
    <input type="file" id="uploader" accept="image/*"><br>
    <input type="text" id="wmText" placeholder="透かし文字を入力" value="SAMPLE">
</div>

<div class="contents_block">
    <!-- canvasは非表示にして、imgに最終結果を表示 -->
    <canvas id="preview" style="display:none;"></canvas>
    <img id="result" class="" alt="加工後画像">
</div>


<div class="contents_block">
    <h3>本ページでの透かし処理について</h3>
    <p>
        このページでは、透かしの追加処理をすべてお使いのブラウザ上で行います。
        元の画像はサーバーにアップロードされることはなく、デバイス内で完結するため、
        管理者や第三者が元画像を閲覧することは一切ありません。
    </p>
    <p>
        そのため、プライバシーを保護したまま安全に画像に透かしを追加することができます。
        また、処理結果はブラウザ上で即座にプレビューされ、ダウンロードも可能です。
        元画像の解像度や画質も保持されますので、安心してご利用ください。
    </p>
</div>


<script>
    const uploader = document.getElementById("uploader");
    const wmInput = document.getElementById("wmText");
    const canvas = document.getElementById("preview");
    const ctx = canvas.getContext("2d");
    const resultImg = document.getElementById("result");

    let originalImg = null; // 元画像保持

    // Cookie に保存する関数（1年有効）
    function saveCookie(text) {
        const expireDate = new Date();
        expireDate.setFullYear(expireDate.getFullYear() + 1);
        document.cookie = `watermarkText=${encodeURIComponent(text)}; expires=${expireDate.toUTCString()}; path=/`;
    }

    // ページロード時に Cookie から透かし文字を復元
    window.addEventListener("load", () => {
        const cookies = document.cookie.split("; ").reduce((acc, cur) => {
            const index = cur.indexOf("=");
            const k = cur.slice(0, index).trim();
            const v = cur.slice(index + 1);
            acc[k] = decodeURIComponent(v);
            return acc;
        }, {});
        if (cookies["watermarkText"]) {
            wmInput.value = cookies["watermarkText"];
            // 復元した際にも再度 Cookie に書き込み、期限を更新
            saveCookie(cookies["watermarkText"]);
        }
    });

    uploader.addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = ev => {
            const img = new Image();
            img.onload = () => {
                originalImg = img;
                drawWithWatermark(img, wmInput.value);
            };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    });

    // input の変更時に Cookie に保存
    wmInput.addEventListener("input", () => {
        saveCookie(wmInput.value);
    });

    // input のフォーカスが外れたときに透かしを更新
    wmInput.addEventListener("blur", () => {
        if (originalImg) {
            drawWithWatermark(originalImg, wmInput.value);
        }
    });

    function drawWithWatermark(img, text) {
        // キャンバスを画像サイズに合わせる
        canvas.width = img.width;
        canvas.height = img.height;

        // 元画像描画
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);

        // 長辺を10分割
        const longSide = Math.max(img.width, img.height);
        const step = longSide / 10;

        // フォントサイズ決定
        let fontSize = step * 0.8;
        ctx.font = `${fontSize}px "PixelMplus12 Regular", "游ゴシック体", YuGothic, "游ゴシック", "Yu Gothic", "Hiragino Kaku Gothic Pro", "メイリオ", Meiryo, "MS Pゴシック", "MS PGothic", sans-serif`;
        let textWidth = ctx.measureText(text).width;
        if (textWidth > step * 0.9) {
            fontSize = (step * 0.9 / textWidth) * fontSize;
            ctx.font = `${fontSize}px "PixelMplus12 Regular", "游ゴシック体", YuGothic, "游ゴシック", "Yu Gothic", "Hiragino Kaku Gothic Pro", "メイリオ", Meiryo, "MS Pゴシック", "MS PGothic", sans-serif`;
        }

        // 文字色と透明度
        ctx.fillStyle = "rgba(128,128,128,0.5)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // 中央基準で敷き詰め
        const centerX = img.width / 2;
        const centerY = img.height / 2;
        for (let y = centerY - step * 10; y <= centerY + step * 10; y += step) {
            for (let x = centerX - step * 10; x <= centerX + step * 10; x += step) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(text, 0, 0);
                ctx.restore();
            }
        }

        // canvas → img に変換して表示
        resultImg.src = canvas.toDataURL("image/png");
    }
</script>
